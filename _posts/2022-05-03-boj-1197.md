---
published: true
title:  "[BOJ/ë°±ì¤€] 1197. ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (Python) "
excerpt: "Prim, Kruskal Algorithm"

categories:
  - PS
tags:
  - [BOJ, Python, Prim, Kruskal]

toc: true
toc_sticky: true
 
date: 2022-05-03 17:25:20
last_modified_at: 2022-05-03 17:25:22
---
# ğŸ” ë¬¸ì œ
[ğŸ”— ë°±ì¤€ 1197. ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬](https://www.acmicpc.net/problem/1197)

# ğŸ’¡ í’€ì´

ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬, MST, Minimum Spanning Tree)ë¥¼ ì—°ìŠµí•˜ëŠ” ë¬¸ì œì˜€ë‹¤. Spanning Treeë€ ëª¨ë“  ì •ì ì´ ì—°ê²°ëœ íŠ¸ë¦¬ë¥¼ ë§í•˜ê³ , Minimum Spanning Treeë€ ê·¸ ì—°ê²°ëœ ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì¸ ê²½ìš°ë¥¼ ë§í•œë‹¤.

ì´ë•ŒëŠ” ë³´í†µ **í¬ë£¨ìŠ¤ì¹¼(Kruskal)**, **í”„ë¦¼(Prim)** ì•Œê³ ë¦¬ì¦˜ì„ ì“´ë‹¤.

ì‹œê°„ë³µì¡ë„:
- í”„ë¦¼(Prim): O(ElogV)
- í¬ë£¨ìŠ¤ì¹¼(Kruskal) : O(ElogE)

ë”°ë¼ì„œ ê°„ì„ ì´ ë§ì„ë• í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜, ê°„ì„ ì´ ì ìœ¼ë©´ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì“°ë©´ ëœë‹¤.

ì˜›ë‚ ì— ë°°ìš´ê±°ë¼ ë³µìŠµì°¨ì›ì—ì„œ í’€ì–´ë´¤ëŠ”ë°, ë‚˜ì¤‘ì— ê¼­ í•œë²ˆ ì •ë¦¬í•´ ë´ì•¼ê² ë‹¤..


# ğŸ“ƒ ì†ŒìŠ¤ì½”ë“œ

## í¬ë£¨ìŠ¤ì¹¼(Kruskal)
```python
from sys import stdin

V, E = map(int, input().split())

edges = []
parent = [i for i in range(V + 1)]
result = 0

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]
    
def union(a, b):
    a = find(a)
    b = find(b)
    
    if a == b: return
    else: parent[b] = a
    
def is_union(a, b):
    if find(a) == find(b): return True
    else: return False

for _ in range(E):
    u, v, w = map(int, stdin.readline().split())
    edges.append((w, v, u)) # ê°€ì¤‘ì¹˜, ì‹œì‘, ë„ì°©

edges.sort() # ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

for edge in edges:
    w, u, v = edge
    if not is_union(u, v):
        union(u, v)
        result += w

print(result)
```

## í”„ë¦¼(Prim)
```python
from collections import defaultdict
from sys import stdin
import heapq

graph = defaultdict(list)
connected = []

V, E = map(int, input().split())
for _ in range(E):
    u, v, w = map(int, stdin.readline().split())
    graph[u].append((w, u, v)) # ê°€ì¤‘ì¹˜, ì‹œì‘, ë„ì°©
    graph[v].append((w, v, u)) # ë¬´ë°©í–¥ ê·¸ë˜í”„

def prim(start):
    connected.append(start)
    neighbors = graph[start]
    heapq.heapify(neighbors)
    mst = []
    result = 0
    
    while neighbors:
        w, u, v = heapq.heappop(neighbors)
        if v not in connected:
            connected.append(v)
            mst.append((u, v))
            result += w
            
            for edge in graph[v]:
                if edge[2] not in connected:
                    heapq.heappush(neighbors, edge)
                    
    return result

print(prim(1))
```
![image](https://user-images.githubusercontent.com/67352902/166424675-41921b9a-a92a-4d3b-a1ec-edd21bb65f99.png){: .align-center}
*ìœ„: Prim, ì•„ë˜: Kruskal*
<br>