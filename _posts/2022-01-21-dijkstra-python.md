---
published: true
title:  "[Algorithm] ë‹¤ìµìŠ¤íŠ¸ë¼(Dijkstra) êµ¬í˜„ (Python)"
excerpt: "ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ íŒŒì´ì¬ìœ¼ë¡œ êµ¬í˜„í•´ ë³´ì"

categories:
  - Algorithm
tags:
  - [ë‹¤ìµìŠ¤íŠ¸ë¼, Python]

toc: true
toc_sticky: true
 
date: 2022-01-21
last_modified_at: 2022-01-21
---
<br>

> â— ì´ í¬ìŠ¤íŠ¸ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì•Œê³  ìˆë‹¤ëŠ” ì „ì œ í•˜ì— ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ íŒŒì´ì¬ìœ¼ë¡œ ì–´ë–»ê²Œ êµ¬í˜„í• ê¹Œì— ëŒ€í•œ ê¸€ ì…ë‹ˆë‹¤ ğŸ™‡â€â™€ï¸

# ë‹¤ìµìŠ¤íŠ¸ë¼ ì˜ì‚¬ ì½”ë“œ
ì¶œì²˜ : [ìœ„í‚¤í”¼ë””ì•„](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#%EC%9D%98%EC%82%AC_%EC%BD%94%EB%93%9C)
```text
function Dijkstra(Graph, source):
    dist[source] â† 0                                    // ì´ˆê¸°í™”

    create vertex set Q

    for each vertex v in Graph:    // ì´ˆê¸°í™”
        if v â‰  source
            dist[v] â† INFINITY                          // ì†ŒìŠ¤ì—ì„œ vê¹Œì§€ì˜ ì•„ì§ ëª¨ë¥´ëŠ” ê¸¸ì´
            prev[v] â† UNDEFINED                             // vì˜ ì´ì „ ë…¸ë“œ

            Q.add_with_priority(v, dist[v])
    
     while Q is not empty:                          // ë©”ì¸ ë£¨í”„
        u â† Q.extract_min()                         // ìµœê³ ì˜ ê¼­ì§“ì ì„ ì œê±°í•˜ê³  ë°˜í™˜í•œë‹¤
        for each neighbor v of u:              // Qì— ì—¬ì „íˆ ë‚¨ì•„ ìˆëŠ” vì— ëŒ€í•´ì„œë§Œ
            alt â† dist[u] + length(u, v)
            if alt < dist[v]
                dist[v] â† alt
                prev[v] â† u
                Q.decrease_priority(v, alt)

    return dist, prev
```

# íŒŒì´ì¬ìœ¼ë¡œ êµ¬í˜„í•˜ê¸°

ë¨¼ì € ê·¸ë˜í”„ëŠ” ì´ë ‡ê²Œ êµ¬ì„±í•œë‹¤.
```python
# ------- ì…ë ¥ ë°›ê¸° ì‹œì‘ ------
N = int(input()) # ë…¸ë“œ ê°¯ìˆ˜
M = int(input()) # ê°„ì„  ê°¯ìˆ˜

graph = collections.defaultdict(list)

for _ in range(M):
    # ì¶œë°œ, ë„ì°©, ê°€ì¤‘ì¹˜
    u, v, w = map(int, input().split())
    graph[u].append((v, w))

start = int(input())
# ------- ì…ë ¥ ë°›ê¸° ë ------

dist = collections.defaultdict(int) # ê±°ë¦¬
```
`collections.defaultdict`ë¥¼ ì´ìš©í•´ í•´ë‹¹ í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ì—ë„ ë”°ë¡œ ifë¬¸ì„ í†µí•œ ê²€ì‚¬ ì—†ì´ ì‚½ì…í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

keyë¡œ ì¶œë°œë…¸ë“œ, valueë¡œ (ë„ì°©ë…¸ë“œ, ê°€ì¤‘ì¹˜) ë¥¼ ê°–ëŠ”ë‹¤.

distë„ ë˜‘ê°™ì´ `collections.defaultdict`ë¥¼ ì´ìš©í•˜ê³  ê¸°ë³¸ê°’ì€ `int` ì´ë‹¤.

```python
Q = [(0, start)]
```
í ë³€ìˆ˜ QëŠ” (ê°€ì¤‘ì¹˜, ì •ì ) ìœ¼ë¡œ êµ¬ì„±í•œë‹¤.

ì²˜ìŒ ì‹œì‘ì ì´ë¯€ë¡œ (0, start)ë¥¼ íì— ì‚½ì…í•´ì¤€ë‹¤.

ë‹¤ìŒìœ¼ë¡œ Që¥¼ ìˆœíšŒí•˜ë©´ì„œ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ì •ì ì„ ì°¨ë¡€ë¡œ ë°©ë¬¸í•˜ë©° ì´ ì†Œìš”ëœ ê°€ì¤‘ì¹˜ì˜ í•©ì„ êµ¬í•œë‹¤.

ìµœì†Œí™ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ íŒŒì´ì¬ì˜ `heapq`ë¥¼ ì‚¬ìš©í–ˆë‹¤. íŒŒì´ì¬ì—ë„ PriorityQueueê°€ ìˆì§€ë§Œ, íŒŒì´ì¬ì˜ ìš°ì„ ìˆœìœ„íëŠ” ì‚¬ì‹¤ ë‚´ë¶€ì ìœ¼ë¡œ `heapq`ë¡œ êµ¬í˜„ë˜ì–´ ìˆì–´ ë³´í†µ `heapq`ë¥¼ ì‚¬ìš©í•œë‹¤.

ìœ„ì˜ ì˜ì‚¬ì½”ë“œì—ì„œëŠ” ì•„ì§ ëª¨ë¥´ëŠ” ê¸¸ì´ë¥¼ ë¬´í•œëŒ€ë¡œ ì„¤ì •í•˜ê³  ê±°ë¦¬ë¥¼ ë¹„êµí•˜ë©° ê°±ì‹ í•´ ë‚˜ê°”ë‹¤. ê·¸ë¦¬ê³  ë’¤ì—ì„  `Q.decrease_priority`ë¥¼ ì´ìš©í•´ ìš°ì„ ìˆœìœ„ë¥¼ ì¡°ì •í•˜ëŠ”ë° íŒŒì´ì¬ì˜ `heapq`ì—ëŠ” ê·¸ëŸ¬í•œ ê¸°ëŠ¥ì´ ì—†ë‹¤.

ë”°ë¼ì„œ `Q.decrease_priority` ê°€ í•„ìš” ì—†ë„ë¡ êµ¬í˜„ í•´ì•¼í•œë‹¤.

```python
while Q:
    # ê°€ì¤‘ì¹˜ ê°€ì¥ ì ì€ê²ƒ pop, Qìµœì†Œí™
    time, node = heapq.heappop(Q)
    # í•´ë‹¹ ë…¸ë“œì— ì²˜ìŒ ë°©ë¬¸ í•  ë•Œì—ë§Œ
    if node not in dist:
        dist[node] = time
        for v, w in graph[node]:
            alt = time + w
            heapq.heappush(Q, (alt, v))
```

í ìˆœíšŒë¥¼ ì‹œì‘í•˜ìë§ˆì ìµœì†Ÿê°’ì„ ì¶”ì¶œí•˜ëŠ”ê²ƒì€ ì˜ì‚¬ì½”ë“œì™€ ë™ì¼í•˜ë‹¤. `Q.extract_min()`ì„ `heapq.heappop(Q)`ê°€ ëŒ€ì‹ í•œë‹¤.

ì˜ì‚¬ì½”ë“œì—ì„œëŠ” ìµœì†Ÿê°’ì„ ì¶”ì¶œí•˜ê³  ì´ì›ƒ ë…¸ë“œë¥¼ ìˆœíšŒí•˜ëŠ” ë°˜ë©´ ìš°ë¦¬ëŠ” ë¨¼ì € distì— nodeê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ê²€ì‚¬í•œë‹¤.

ì˜ì‚¬ì½”ë“œì—ì„  distë¥¼ ë¬´í•œëŒ€ë¡œ ì´ˆê¸°í™” ì‹œì¼œë†“ì•˜ì§€ë§Œ ìš°ë¦¬ëŠ” ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œëŠ” ë¹„ì–´ìˆëŠ” ìƒíƒœì´ë‹¤.

ë”°ë¼ì„œ `dist[node]` ê°’ì´ ë¹„ì–´ìˆì„ ë•Œì—ë§Œ íì— push í•œë‹¤. ì´ë ‡ê²Œ ë˜ë©´ distì—ëŠ” í•­ìƒ ìµœì†Ÿê°’ë§Œ ì…‹íŒ…ëœë‹¤.

<hr>

ëª¨ë“  ì‘ì—…ì´ ëë‚˜ê²Œ ë˜ë©´ dist ë”•ì…”ë„ˆë¦¬ì— ëª¨ë“  ë…¸ë“œì— ëŒ€í•œ ìµœë‹¨ ê²½ë¡œê°€ ë“¤ì–´ìˆì„ê²ƒì´ë‹¤. ë§Œì•½ í‚¤ì˜ ê°¯ìˆ˜ê°€ ë…¸ë“œì˜ ê°¯ìˆ˜ì™€ ë™ì¼í•˜ì§€ ì•Šë‹¤ë©´ ê·¸ ë…¸ë“œëŠ” ì‹œì‘ì ì—ì„œ ê°ˆ ìˆ˜ ì—†ëŠ” ë…¸ë“œì¸ê²ƒì´ë‹¤.

[ë°±ì¤€ 1916 ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°](https://devyuseon.github.io/boj/boj-1916/) ì—ì„œëŠ” ì¶œë°œì ì—ì„œ ë„ì°©ì ì„ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ë§Œ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤ê³  í–ˆìœ¼ë‹ˆ ê¸¸ì´ë¥¼ ê²€ì‚¬í•˜ì§€ ì•ŠëŠ”ë‹¤.

ëë¶€ë¶„ì˜ ì²˜ë¦¬ëŠ” ë¬¸ì œë§ˆë‹¤ ë‹¤ë¥´ë¯€ë¡œ ì˜ ì‚´í´ë´ì•¼ í•œë‹¤.


# ì „ì²´ ì†ŒìŠ¤ì½”ë“œ

```python
import sys
import collections
import heapq
input = sys.stdin.readline

def dijkstra(start):
    # (ê°€ì¤‘ì¹˜, ì •ì )
    Q = [(0, start)]

    while Q:
        # ê°€ì¤‘ì¹˜ ê°€ì¥ ì ì€ê²ƒ pop, Qìµœì†Œí™
        time, node = heapq.heappop(Q)
        # í•´ë‹¹ ë…¸ë“œì— ì²˜ìŒ ë°©ë¬¸ í•  ë•Œì—ë§Œ
        if node not in dist:
            dist[node] = time
            for v, w in graph[node]:
                alt = time + w
                heapq.heappush(Q, (alt, v))

# ------- ì…ë ¥ ë°›ê¸° ì‹œì‘ ------
N = int(input()) # ë…¸ë“œ ê°¯ìˆ˜
M = int(input()) # ê°„ì„  ê°¯ìˆ˜

graph = collections.defaultdict(list)

for _ in range(M):
    # ì¶œë°œ, ë„ì°©, ê°€ì¤‘ì¹˜
    u, v, w = map(int, input().split())
    graph[u].append((v, w))

start = int(input())
# ------- ì…ë ¥ ë°›ê¸° ë ------

dist = collections.defaultdict(int) # ê±°ë¦¬
dijkstra(start)

for k, v in dist.items():
    print(f"ë…¸ë“œ: {k}, ê±°ë¦¬: {v}")
```

**ì…ë ¥**
```text
5
8
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
1
```

**ì¶œë ¥**
```text
ë…¸ë“œ: 1, ê±°ë¦¬: 0
ë…¸ë“œ: 4, ê±°ë¦¬: 1
ë…¸ë“œ: 2, ê±°ë¦¬: 2
ë…¸ë“œ: 3, ê±°ë¦¬: 3
ë…¸ë“œ: 5, ê±°ë¦¬: 4
```